from app.dependancies.db_dependancy import DbSessionDep
from fastapi import APIRouter, HTTPException, status
from sqlalchemy.future import select
from sqlalchemy import delete
from app.schemas.shipment import CreateShipment, ReadShipment, UpdateShipment
from app.database.db_models import Shipment

router = APIRouter(prefix="/shipment")


@router.post("/create", response_model=ReadShipment)
async def create_shipment(shipment: CreateShipment, db: DbSessionDep):

    # first lets create schema to python dict
    data = shipment.model_dump()

    to_add = Shipment(**data)

    db.add(to_add)
    await db.commit()
    await db.refresh(to_add)
    # some fields are auto generated by the database itself
    # so we use refresh() to update our python object with those db's auto generated value

    return to_add


@router.get("/{shipment_id}", response_model=ReadShipment)
async def get_shipment(shipment_id: str, db: DbSessionDep):

    query = select(Shipment).where(
        Shipment.id == shipment_id
    )  # builds a sql expression object

    res = await db.execute(query)
    final_res = res.scalar_one_or_none()

    if not final_res:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="The id you provided does not exist",
        )
    return final_res


@router.patch("/{shipment_id}", response_model=ReadShipment)
async def update_shipment(
    shipment_id: str, shipment_update: UpdateShipment, db: DbSessionDep
):

    query = select(Shipment).where(
        Shipment.id == shipment_id
    )  # builds a sql expression object

    res = await db.execute(query)
    final_res = res.scalar_one_or_none()
    ##Now final_res is a live ORM object attached to the session
    ## now we can just modify this object in memory and
    ### when we commit sqlalchemy checks if there are any changes and updates those changes
    if not final_res:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="The id you provided does not exist",
        )

    data = shipment_update.model_dump(exclude_unset=True)

    for key, value in data.items():
        setattr(final_res, key, value)

    # what this loop does is update attribute names dynamically
    # dynamically does
    # final_res.weight = 15
    # final_res.status = "SHIPPED"
    # But without hardcoding field names.
    # as patch method is dynamic we dont know what data user may send

    await db.commit()
    await db.refresh(final_res)

    return final_res


@router.delete("/{shipment_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_shipment(shipment_id: str, db: DbSessionDep):

    # easy approach we can do using sqlalchemy
    # prefer this as does a single db operation -> delete
    stmt = delete(Shipment).where(Shipment.id == shipment_id)
    result = await db.execute(stmt)
    await db.commit()
    if result.rowcount == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="Shipment not found"
        )

    return  # or return nothing

    # using orm style ->
    # query = select(Shipment).where(Shipment.id == shipment_id)
    # res = await db.execute(query)
    # obj = res.scalar_one_or_none()
    # if not obj:
    #     raise HTTPException(
    #         status_code=status.HTTP_404_NOT_FOUND,
    #         detail="Shipment not found"
    #     )
    # await db.delete(obj)
    # await db.commit()
    # return {"message": "Shipment deleted successfully"}
    # SELECT → fetch row
    # Load it as ORM object
    # db.delete(obj) → mark object as deleted in session
    # commit() → generates
    # This performs 1 SELECT 1 DELETE -> Two DB operations.
